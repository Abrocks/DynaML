package io.github.mandar2812.dynaml.kernels

import breeze.linalg.{DenseMatrix, inv, pinv}
import io.github.mandar2812.dynaml.utils

/**
  * @author mandar2812 date: 30/08/16.
  *
  * In co-regionalization models for multi-output gaussian processes,
  * one comes across the graph regularizer. the class below is an implementation
  * of such.
  *
  * @param m The symmetric adjacency matrix of the graph generated by the nodes indexed
  *          by integers.
  */
class CoRegGraphKernel(m: DenseMatrix[Double]) extends LocalSVMKernel[Int] {

  utils.isSquareMatrix(m)

  utils.isSymmetricMatrix(m)

  val dimensions = m.rows

  state = {
    for(i <- 0 until dimensions; j <- 0 until dimensions)
      yield (i,j)
  }.filter((coup) => coup._1 <= coup._2)
    .map(c => "M_"+c._1+"_"+c._2 -> m(c._1, c._2))
    .toMap

  override val hyper_parameters: List[String] = state.keys.toList

  def adjecancyMatrix = DenseMatrix.tabulate[Double](dimensions, dimensions){(i, j) =>
    if(i <= j) state("M_"+i+"_"+j)
    else state("M_"+j+"_"+i)
  }

  def degreeMatrix =
    DenseMatrix.eye[Double](dimensions) :*
      ((adjecancyMatrix * DenseMatrix.ones[Double](dimensions, dimensions)) + adjecancyMatrix)

  def l: DenseMatrix[Double] = pinv(degreeMatrix - adjecancyMatrix)


  override def gradient(x: Int, y: Int): Map[String, Double] = hyper_parameters.map(_ -> 1.0).toMap

  override def evaluate(x: Int, y: Int): Double = l(x,y)

}
