//Uncertainty Quantification Benchmarks
import breeze.linalg.DenseVector
import io.github.mandar2812.dynaml.analysis.VectorField
import io.github.mandar2812.dynaml.models.gp.GPRegression
import io.github.mandar2812.dynaml.optimization.{CoupledSimulatedAnnealing, GridSearch}
import breeze.stats.distributions.Uniform
import io.github.mandar2812.dynaml.kernels.{MLPKernel, PeriodicKernel}
import io.github.mandar2812.dynaml.probability.{GaussianRV, IIDRandomVarDistr, ProbabilityModel, RandomVariable}
import spire.implicits._


val num_features = 1
implicit val ev = VectorField(num_features)

val xPrior = RandomVariable(new Uniform(-4.0, 4.0))
val iidXPrior = IIDRandomVarDistr(xPrior) _


val likelihood = DataPipe((x: Double) => GaussianRV(math.atan(1000.0*x*x*x), 0.4))

val model = ProbabilityModel(xPrior, likelihood)

val data: Stream[(DenseVector[Double], Double)] =
  (1 to 500).map(_ => model.sample()).map(c => (DenseVector(c._1), c._2)).toStream

val testData = (1 to 500).map(_ => model.sample()).map(c => (DenseVector(c._1), c._2)).toStream


val kernel = new RBFKernel(4.5)
val mlpkernel = new MLPKernel(40.0,4.0)

val noise = new DiracKernel(1.0)

val startConf = mlpkernel.state ++ noise.state
val gpModel = new GPRegression(mlpkernel, noise, data)

val gs =
  new GridSearch(gpModel).setGridSize(3).setStepSize(0.2).setLogScale(false)

val (tunedGP, _) = gs.optimize(startConf)

tunedGP.persist()

val gpLikelihood = DataPipe((x: Double) => {
  //val xStream = x.map(DenseVector(_))
  //tunedGP.predictiveDistribution(xStream)
  val pD = tunedGP.predictiveDistribution(Seq(DenseVector(x)))
  GaussianRV(pD.mu(0), pD.covariance(0,0))
})

val gpProbModel = ProbabilityModel(xPrior, gpLikelihood)

val gpTestSet = (1 to testData.length).map(_ => gpProbModel.sample()).toStream

scatter(testData.map(c => (c._1(0), c._2)))
hold()
scatter(gpTestSet)
unhold()
title("Comparison of Noisy Data versus inferred function")

//Histogram of test data
histogram(testData.map(_._2))
//Histogram generated by GP Probability Model
histogram(gpTestSet.map(_._2))

val likelihood2 = DataPipe((x: Double) => GaussianRV(1/(2.0 + math.sin(3*math.Pi*x)), 0.08))

val model2 = ProbabilityModel(xPrior, likelihood2)

val data2: Stream[(DenseVector[Double], Double)] =
  (1 to 500).map(_ => model2.sample()).map(c => (DenseVector(c._1), c._2)).toStream

val testData2 = (1 to 500).map(_ => model2.sample()).map(c => (DenseVector(c._1), c._2)).toStream

//scatter(testData2.map(c => (c._1(0), c._2)))

val perKernel = new WaveKernel(0.9) //PeriodicKernel(1.3, 1.5)
val noise = new DiracKernel(0.7)

val startConf2 = perKernel.state ++ noise.state

val gpModel2 = new GPRegression(perKernel, noise, data2)

val gs2 =
  new CoupledSimulatedAnnealing(gpModel2).setGridSize(2).setStepSize(0.2).setLogScale(false)

val (tunedGP2, _) = gs2.optimize(startConf2)

tunedGP2.persist()

val gpLikelihood2 = DataPipe((x: Double) => {
  //val xStream = x.map(DenseVector(_))
  //tunedGP.predictiveDistribution(xStream)
  val pD = tunedGP2.predictiveDistribution(Seq(DenseVector(x)))
  GaussianRV(pD.mu(0), pD.covariance(0,0))
})

val gpProbModel2 = ProbabilityModel(xPrior, gpLikelihood2)

val gpTestSet2 = (1 to testData2.length).map(_ => gpProbModel2.sample()).toStream
//scatter(gpTestSet2)

scatter(testData2.map(c => (c._1(0), c._2)))
hold()
scatter(gpTestSet2)
unhold()
title("Comparison of Noisy Data and inferred function for the case y ~ N(1/(2 + sin(3*pi*x))^2, 0.08)")



//Histogram of test data
histogram(testData2.map(_._2))

//Histogram generated by GP Probability Model
histogram(gpTestSet2.map(_._2))
